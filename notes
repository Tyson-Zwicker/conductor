
Kinds of game objects:

1. Game Entity:
  - exists in game coordinates which can change
  - can rotate
  - has own velocity and spin (is Mover)
  - on screen position affected by the camera position and zoom levels.
  - can interact with mouse
  - can contain subparts
  - can have text label (with offset, affected by zoom level)
  - must have concept of toggle and radio

2. Particle:
  - has own velocity (is Mover)
  - exists in game coordinates which change
  - position can change with camera and zoom levels
  - do not interact with mouse.
  - do not have label

3. Button:
  - fixed on screen position (no game coordinates) (is NOT mover)
  - bounds do not need to be recalculated.
  - can interact with mouse
  - can have text label (fixed offset - centered in bounds)
  - must have concept toggle and radio

Commonality:

  - they all need to have bounds in order to work with the mouse
  - they all need to have a sprite to represent them
  - most need a click event
  - most need a hover and press alternate sprite
  - most need a toggle setting.
  - most need a text label
  - buttons need a "fixed screen" coordinate.

TASKS:
  * +allow for unfilled sprite
  * +attach text (with offset)
  * +add camera translation 
  * +add camera zoom functionality to draw..
  * +add fixed screen coords (for buttons)
  * +add mouse-wheel event, provide an option for the user to enable it, and have it change the camera zoom level 
    automatically.
  * +add alternate sprites for hover and press.
  * +test mouse functionality.
  * add parts.
  * add velocity and spin
  * implement a color system (for particle fade)
  * add particles
  * add a function that will add a user-defined function to be called when the canvas is clicked, but no game object was
    the recipient of the click (the mouse clicked nothing)
  

  Parts:

{name, sprites[](polar), orientation, offset(polar)}
  
  - Make the setter use an object not an array..
  - Add getters
  - Add draw method.

*** You need  to a "part factory" (see: addSpriteTo) that
will convert the cartesians to polars, and it calls objects.addPart
with the polar coordinates already converted.. ***

 object.addPartSprite(partname, polarizedSprite);
 object.addPart(partname, offset, orientation);

  NEW CODE FROM CONDUCTOR:
           "addPart": function (partName, sprites, offset, initalOrientation) {
              if (Object.hasOwn(parts, partName)) {
                throw new Error (`${name} already contains part '${partName}'`);
              }
              if (sprites.length<1){
                throw new Error ('parts must have at least one sprite.');
              }
              let part = {
                "name":partName,
                "sprites": sprites,
                "orientation": (initalOrientation)?initalOrientation:0,
                "offset": offset
              }
              this.parts[partName]=part;
            },
            /**
             *  Gets the parts for this object. The parts are stored as an object
             * where the property of the part the part name.
             * @returns An object containing all the parts.
            */
            "getParts":function (){
              return parts;
            },
            /**
             * Get an individual part of the object.
             * @param {string} partName the name of the part to be returned
             * @returns the part {name, sprites, orientation, offset}
             */
            "getPart": function(partName){
              if (Object.hasOwn (parts, partName)){
                return parts[partName];
              }else{
                throw new Error (`${name} does not have part ${partName}.`);
              }
            },

  OLD CODE FROM "ENGINE":

  const Part = function (name,sprite, offset, orientation) {
    this.name = name;
    this.sprite = sprite;
    this.orientation = (orientation) ? orientation : 0;
    this.owner = undefined;
    this.offset = (offset) ? new Point(offset.x, offset.y).toVector() : new Vector(0, 0);
}
//offset parameter is the "owners" screen coordinates.
Part.prototype.draw = function (ownerLocation) {
    let x = ownerLocation.x;
    let partLocation = {
        x: ownerLocation.x + cos(this.offset.angle+this.owner.angle) * this.offset.length * _zoom,
        y: ownerLocation.y + sin(this.offset.angle+this.owner.angle) * this.offset.length * _zoom
    };
    let orientation = this.orientation + this.owner.angle;
    this.sprite.draw(orientation, partLocation);
}
Part.prototype.clone = function (){
    return new Part (this.name, this.sprite, this.offset.toPoint(), this.orientation);
} 